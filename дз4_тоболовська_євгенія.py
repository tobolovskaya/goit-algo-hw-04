# -*- coding: utf-8 -*-
"""ДЗ4_Тоболовська Євгенія.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/110BNIN6FEo5TbY-_Js5cLhs4SKHD39ud

Порівняльний аналіз алгоритмів за часом виконання шляхом їх тестування на різних наборах даних.
"""

import random
import timeit

# Задаємо функції сортування
def insertion_sort(data):
    for i in range(1, len(data)):
        key = data[i]
        j = i - 1
        while j >=0 and key < data[j]:
            data[j + 1] = data[j]
            j -= 1
        data[j + 1] = key
    return data

def merge_sort(data):
    if len(data) > 1:
        mid = len(data) // 2
        L = data[:mid]
        R = data[mid:]

        merge_sort(L)
        merge_sort(R)

        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                data[k] = L[i]
                i += 1
            else:
                data[k] = R[j]
                j += 1
            k += 1

        while i < len(L):
            data[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            data[k] = R[j]
            j += 1
            k += 1
    return data

# Функція для генерації наборів даних
def generate_datasets(size):
    random_data = [random.randint(0, size) for _ in range(size)]
    sorted_data = list(range(size))
    reversed_data = list(range(size, 0, -1))
    return random_data, sorted_data, reversed_data

# Функція для тестування алгоритмів сортування
def test_sorting_algorithms(datasets):
    results = {}
    for i, data in enumerate(datasets):
        dataset_type = ['Random', 'Sorted', 'Reversed'][i]
        print(f"Testing {dataset_type} dataset")

        # Тестування бульбашкового сортування
        results[dataset_type] = {}
        results[dataset_type]['Timsort'] = min(timeit.repeat(lambda: sorted(data), number=1, repeat=5))
        results[dataset_type]['Merge Sort'] = min(timeit.repeat(lambda: merge_sort(data[:]), number=1, repeat=5))
        results[dataset_type]['Insertion Sort'] = min(timeit.repeat(lambda: insertion_sort(data[:]), number=1, repeat=5))

    return results

# Генеруємо набори даних різного типу
datasets = generate_datasets(1000)  # Змініть розмір за потребою

# Тестуємо алгоритми сортування та друкуємо результати
results = test_sorting_algorithms(datasets)
for dataset_type, result in results.items():
    print(f"\n{dataset_type} dataset:")
    for sort_type, time in result.items():
        print(f"{sort_type} took {time:.5f} seconds")

"""Емпірично перевірено теоретичні оцінки складності алгоритмів та доведено, що поєднання сортування злиттям і сортування вставками робить алгоритм Timsort набагато ефективнішим."""

import timeit

def time_sorting_algorithms(data):
    results = {
        'Insertion Sort': min(timeit.repeat(lambda: insertion_sort(data[:]), number=1, repeat=5)),
        'Merge Sort': min(timeit.repeat(lambda: merge_sort(data[:]), number=1, repeat=5)),
        'Timsort (built-in sorted)': min(timeit.repeat(lambda: sorted(data), number=1, repeat=5))
    }
    return results

sizes = [100, 1000, 10000]
for size in sizes:
    data = [random.randint(0, size) for _ in range(size)]
    print(f"\nSorting array of size {size}")
    results = time_sorting_algorithms(data)
    for sort_name, time_taken in results.items():
        print(f"{sort_name}: {time_taken:.5f} seconds")