Сортування вставками (Insertion Sort): Цей алгоритм, як було показано, виконується досить швидко на маленьких масивах або на масивах, які вже майже відсортовані. 
Однак, його продуктивність різко знижується зі збільшенням кількості елементів, що підтверджує його квадратичну складність O(n^2). Він може бути неефективним для великих наборів даних.

Сортування злиттям (Merge Sort): Цей алгоритм показав значно кращі результати, особливо на великих масивах. Його час виконання зростає пропорційно до n log n, де n - кількість елементів у масиві. 
Сортування злиттям є стабільним і передбачуваним, що робить його хорошим вибором для великих наборів даних.

Timsort (вбудоване сортування Python): Цей гібридний алгоритм показав найкращі результати на всіх тестових наборах даних. 
Він оптимізований для реальних даних, які часто містять вже відсортовані або частково відсортовані сегменти. 
Ефективність Timsort полягає в його здатності швидко виконувати сортування на таких сегментах, забезпечуючи найкращу можливу продуктивність в реальних умовах, 
що підтверджує його складність O(n log n) у середньому випадку.

Враховуючи ці результати, можна зробити висновок, що для більшості реальних сценаріїв використання вбудований алгоритм сортування в Python (Timsort) є найбільш ефективним вибором, 
завдяки його здатності до адаптації до різних типів вхідних даних і швидкому виконанню на практичних наборах даних.
# goit-algo-hw-04
